// Importing required dependencies for resolvers, error handling, and complexity analysis
import { ApolloError } from 'apollo-server';
import { rankActivities } from '../utils/activityRanking';
import { Resolvers } from '../schema/types'; // Generated by codegen
import { getComplexity, simpleEstimator } from 'graphql-query-complexity';
import { DocumentNode } from 'graphql';

// Defining complexity estimators for query fields
// Assigns costs based on expected resource usage
const complexityEstimators = [
  simpleEstimator({
    defaultComplexity: 1, // Default cost for scalar fields
  }),
];

// Defining the GraphQL resolvers for query operations
// Maps query fields to data source methods, handles errors, and supports complexity analysis
export const resolvers: Resolvers = {
  Query: {
    // Handling the citySuggestions query
    // Fetches cities matching a search query with pagination support
    // Complexity: Base cost 10 + 2 per city (due to API call and mapping)
    citySuggestions: async (_, { query, limit, offset }, { dataSources }, info) => {
      // Calculating query complexity
      const complexity = getComplexity({
        schema: info.schema,
        query: info.operation as unknown as DocumentNode,
        variables: { query, limit, offset },
        estimators: complexityEstimators,
      });
      // Rejecting queries exceeding complexity threshold
      if (complexity > 1000) {
        throw new ApolloError(`Query too complex: ${complexity} exceeds limit of 1000`, 'COMPLEXITY_EXCEEDED');
      }
      try {
        // Fetching cities from OpenMeteoDataSource with combined limit and offset
        const cities = await dataSources.openMeteo.searchCities(query, limit + offset);
        // Checking if no cities were found
        if (!cities.length) {
          // Throwing ApolloError for empty results
          throw new ApolloError('No cities found for the given query', 'NOT_FOUND');
        }
        // Returning paginated slice of cities
        return cities.slice(offset, offset + limit);
      } catch (error) {
        // Handling errors and throwing ApolloError with detailed message
        const message = (error instanceof Error) ? error.message : String(error);
        throw new ApolloError(`City search failed: ${message}`, 'SEARCH_FAILED');
      }
    },
    // Handling the weatherForecast query
    // Fetches daily weather forecasts for a given location and number of days
    // Complexity: Base cost 20 + 3 per forecast day (due to API call and data processing)
    weatherForecast: async (_, { cityLatitude, cityLongitude, forecastDays }, { dataSources }, info) => {
      // Calculating query complexity
      const complexity = getComplexity({
        schema: info.schema,
        query: info.operation as unknown as DocumentNode,
        variables: { cityLatitude, cityLongitude, forecastDays },
        estimators: complexityEstimators,
      });
      // Rejecting queries exceeding complexity threshold
      if (complexity > 1000) {
        throw new ApolloError(`Query too complex: ${complexity} exceeds limit of 1000`, 'COMPLEXITY_EXCEEDED');
      }
      try {
        // Fetching weather forecast from OpenMeteoDataSource
        const forecast = await dataSources.openMeteo.getWeatherForecast(cityLatitude, cityLongitude, forecastDays);
        // Checking if no forecast data was returned
        if (!forecast.length) {
          // Throwing ApolloError for empty forecast
          throw new ApolloError('No weather forecast available', 'NO_FORECAST');
        }
        // Returning the forecast data
        return forecast;
      } catch (error) {
        // Handling errors and throwing ApolloError with detailed message
        const message = (error instanceof Error) ? error.message : String(error);
        throw new ApolloError(`Weather forecast failed: ${message}`, 'FORECAST_FAILED');
      }
    },
    // Handling the activityRanking query
    // Generates ranked activity recommendations based on weather forecasts
    // Complexity: Base cost 30 (due to weather fetch and ranking computation)
    activityRanking: async (_, { cityLatitude, cityLongitude, forecastDays }, { dataSources }, info) => {
      // Calculating query complexity
      const complexity = getComplexity({
        schema: info.schema,
        query: info.operation as unknown as DocumentNode,
        variables: { cityLatitude, cityLongitude, forecastDays },
        estimators: complexityEstimators,
      });
      // Rejecting queries exceeding complexity threshold
      if (complexity > 1000) {
        throw new ApolloError(`Query too complex: ${complexity} exceeds limit of 1000`, 'COMPLEXITY_EXCEEDED');
      }
      try {
        // Fetching weather forecast for ranking
        const forecast = await dataSources.openMeteo.getWeatherForecast(cityLatitude, cityLongitude, forecastDays);
        // Checking if no forecast data was returned
        if (!forecast.length) {
          // Throwing ApolloError for missing forecast
          throw new ApolloError('No weather forecast available for ranking', 'NO_FORECAST');
        }
        // Computing activity rankings using weather data
        return rankActivities(forecast);
      } catch (error) {
        // Handling errors and throwing ApolloError with detailed message
        const message = (error instanceof Error) ? error.message : String(error);
        throw new ApolloError(`Activity ranking failed: ${message}`, 'RANKING_FAILED');
      }
    },
  },
};