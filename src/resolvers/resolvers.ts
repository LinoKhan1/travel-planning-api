// Importing required dependencies for resolvers and error handling
import { ApolloError } from 'apollo-server';
import { rankActivities } from '../utils/activityRanking';
import { Resolvers } from '../schema/types'; // Generated by codegen

// Defining the GraphQL resolvers for query operations
// Maps query fields to data source methods and handles errors
export const resolvers: Resolvers = {
  Query: {
    // Handling the citySuggestions query
    // Fetches cities matching a search query with pagination support
    citySuggestions: async (_, { query, limit, offset }, { dataSources }) => {
      try {
        // Fetching cities from OpenMeteoDataSource with combined limit and offset
        const cities = await dataSources.openMeteo.searchCities(query, limit + offset);
        // Checking if no cities were found
        if (!cities.length) {
          // Throwing ApolloError for empty results
          throw new ApolloError('No cities found for the given query', 'NOT_FOUND');
        }
        // Returning paginated slice of cities
        return cities.slice(offset, offset + limit);
      } catch (error) {
        // Handling errors and throwing ApolloError with detailed message
        const message = (error instanceof Error) ? error.message : String(error);
        throw new ApolloError(`City search failed: ${message}`, 'SEARCH_FAILED');
      }
    },
    // Handling the weatherForecast query
    // Fetches daily weather forecasts for a given location and number of days
    weatherForecast: async (_, { cityLatitude, cityLongitude, forecastDays }, { dataSources }) => {
      try {
        // Fetching weather forecast from OpenMeteoDataSource
        const forecast = await dataSources.openMeteo.getWeatherForecast(cityLatitude, cityLongitude, forecastDays);
        // Checking if no forecast data was returned
        if (!forecast.length) {
          // Throwing ApolloError for empty forecast
          throw new ApolloError('No weather forecast available', 'NO_FORECAST');
        }
        // Returning the forecast data
        return forecast;
      } catch (error) {
        // Handling errors and throwing ApolloError with detailed message
        const message = (error instanceof Error) ? error.message : String(error);
        throw new ApolloError(`Weather forecast failed: ${message}`, 'FORECAST_FAILED');
      }
    },
    // Handling the activityRanking query
    // Generates ranked activity recommendations based on weather forecasts
    activityRanking: async (_, { cityLatitude, cityLongitude, forecastDays }, { dataSources }) => {
      try {
        // Fetching weather forecast for ranking
        const forecast = await dataSources.openMeteo.getWeatherForecast(cityLatitude, cityLongitude, forecastDays);
        // Checking if no forecast data was returned
        if (!forecast.length) {
          // Throwing ApolloError for missing forecast
          throw new ApolloError('No weather forecast available for ranking', 'NO_FORECAST');
        }
        // Computing activity rankings using weather data
        return rankActivities(forecast);
      } catch (error) {
        // Handling errors and throwing ApolloError with detailed message
        const message = (error instanceof Error) ? error.message : String(error);
        throw new ApolloError(`Activity ranking failed: ${message}`, 'RANKING_FAILED');
      }
    },
  },
};