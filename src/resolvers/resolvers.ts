import { ApolloError } from 'apollo-server';
import { rankActivities } from '../utils/activityRanking';
import { Resolvers } from '../schema/types'; // Generated by codegen

export const resolvers: Resolvers = {
  Query: {
    citySuggestions: async (_, { query, limit, offset }, { dataSources }) => {
      try {
        const cities = await dataSources.openMeteo.searchCities(query, limit + offset);
        if (!cities.length) {
          throw new ApolloError('No cities found for the given query', 'NOT_FOUND');
        }
        return cities.slice(offset, offset + limit);
      } catch (error) {
        const message = (error instanceof Error) ? error.message : String(error);
        throw new ApolloError(`City search failed: ${message}`, 'SEARCH_FAILED');
      }
    },
    weatherForecast: async (_, { cityLatitude, cityLongitude, forecastDays }, { dataSources }) => {
      try {
        const forecast = await dataSources.openMeteo.getWeatherForecast(cityLatitude, cityLongitude, forecastDays);
        if (!forecast.length) {
          throw new ApolloError('No weather forecast available', 'NO_FORECAST');
        }
        return forecast;
      } catch (error) {
        const message = (error instanceof Error) ? error.message : String(error);
        throw new ApolloError(`Weather forecast failed: ${message}`, 'FORECAST_FAILED');
      }
    },
    activityRanking: async (_, { cityLatitude, cityLongitude, forecastDays }, { dataSources }) => {
      try {
        const forecast = await dataSources.openMeteo.getWeatherForecast(cityLatitude, cityLongitude, forecastDays);
        if (!forecast.length) {
          throw new ApolloError('No weather forecast available for ranking', 'NO_FORECAST');
        }
        return rankActivities(forecast);
      } catch (error) {
        const message = (error instanceof Error) ? error.message : String(error);
        throw new ApolloError(`Activity ranking failed: ${message}`, 'RANKING_FAILED');
      }
    },
  },
};