// Importing required dependencies for data source, HTTP requests, and caching
import { DataSource } from 'apollo-datasource';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import { config } from 'dotenv';
import { LRUCache } from 'lru-cache';
import { City, WeatherForecast } from '../schema/types'; // Generated by codegen

// Loading environment variables from .env file
config();

// Defining the GeocodingResponse interface for Open-Meteo geocoding API responses
interface GeocodingResponse {
  results?: Array<{
    id: number;         // Unique city identifier
    name: string;       // City name
    latitude: number;   // City latitude
    longitude: number;  // City longitude
    country?: string;   // Country name (optional)
    population?: number; // City population (optional)
  }>;
}

// Defining the WeatherResponse interface for Open-Meteo weather forecast API responses
interface WeatherResponse {
  daily: {
    time: string[];              // Array of forecast dates
    temperature_2m_max: number[]; // Array of maximum temperatures
    temperature_2m_min: number[]; // Array of minimum temperatures
    precipitation_sum: number[];  // Array of precipitation sums
    wind_speed_10m_max: number[]; // Array of maximum wind speeds
  };
}

// Defining the OpenMeteoDataSource class for interacting with Open-Meteo APIs
// Extends Apollo DataSource to integrate with Apollo Server
export class OpenMeteoDataSource extends DataSource {
  private client: ReturnType<typeof axios.create>; // Axios client for HTTP requests
  private cache: LRUCache<string, City[] | WeatherForecast[]>; // LRU cache for storing API responses

  // Initializing the data source with Axios client and LRU cache configuration
  constructor() {
    super();
    // Creating Axios client for geocoding API requests
    this.client = axios.create({
      baseURL: process.env.OPEN_METEO_GEOCODING_URL || 'https://geocoding-api.open-meteo.com/v1', // Base URL for geocoding API
      timeout: 5000, // Request timeout in milliseconds
    });
    // Configuring retry logic for transient errors (e.g., rate limits, network issues)
    axiosRetry(this.client, {
      retries: 3, // Number of retry attempts
      retryDelay: (retryCount: number) => axiosRetry.exponentialDelay(retryCount), // Exponential backoff for retries
      retryCondition: (error: any) => error.response?.status === 429 || error.code === 'ECONNABORTED' || error.code === 'ERR_NETWORK', // Conditions for retrying
    });
    // Initializing LRU cache with 1-hour TTL and size limit
    this.cache = new LRUCache({
      max: 1000, // Maximum number of cache entries
      ttl: 1000 * 60 * 60, // 1 hour TTL in milliseconds
    });
  }

  // Fetching cities from Open-Meteo geocoding API based on a search query
  // Caches results to reduce API calls, using query and limit as cache key
  async searchCities(query: string, limit: number): Promise<City[]> {
    // Generating cache key based on query and limit
    const cacheKey = `city:${query}:${limit}`;
    // Checking cache for existing results
    const cachedResult = this.cache.get(cacheKey);
    if (cachedResult) {
      // Returning cached results if available
      return cachedResult as City[];
    }
    try {
      // Sending GET request to /search endpoint with query parameters
      const response = await this.client.get<GeocodingResponse>('/search', {
        params: { name: query, count: limit, language: 'en' }, // Query, limit, and language parameters
      });
      // Checking if results are empty or undefined
      if (!response.data.results || response.data.results.length === 0) {
        // Caching empty array to avoid repeated API calls
        this.cache.set(cacheKey, []);
        return [];
      }
      // Mapping API results to City schema type
      const cities = response.data.results.map((result) => ({
        id: result.id.toString(), // Converting numeric ID to string
        name: result.name,
        latitude: result.latitude,
        longitude: result.longitude,
        country: result.country ?? null, // Handling optional country field
        population: result.population ?? null, // Handling optional population field
      }));
      // Caching the results before returning
      this.cache.set(cacheKey, cities);
      return cities;
    } catch (error: any) {
      // Handling errors and throwing with detailed message
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to fetch cities: ${errorMessage}`);
    }
  }

  // Fetching weather forecasts from Open-Meteo API for a given location
  // Caches results to reduce API calls, using latitude, longitude, and forecast days as cache key
  async getWeatherForecast(latitude: number, longitude: number, forecastDays: number): Promise<WeatherForecast[]> {
    // Generating cache key based on latitude, longitude, and forecast days
    const cacheKey = `forecast:${latitude}:${longitude}:${forecastDays}`;
    // Checking cache for existing results
    const cachedResult = this.cache.get(cacheKey);
    if (cachedResult) {
      // Returning cached results if available
      return cachedResult as WeatherForecast[];
    }
    try {
      // Sending GET request to /forecast endpoint with weather parameters
      const response = await this.client.get<WeatherResponse>('/forecast', {
        baseURL: process.env.OPEN_METEO_FORECAST_URL || 'https://api.open-meteo.com/v1', // Base URL for forecast API
        params: {
          latitude, // Latitude of the location
          longitude, // Longitude of the location
          daily: 'temperature_2m_max,temperature_2m_min,precipitation_sum,wind_speed_10m_max', // Requested daily metrics
          timezone: 'auto', // Automatic timezone detection
          forecast_days: forecastDays, // Number of forecast days
        },
      });
      // Extracting daily weather data from response
      const { daily } = response.data;
      // Mapping daily data to WeatherForecast schema type
      const forecasts = daily.time.map((date: string, index: number) => ({
        date,
        temperatureMax: daily.temperature_2m_max[index],
        temperatureMin: daily.temperature_2m_min[index],
        precipitationSum: daily.precipitation_sum[index],
        windSpeedMax: daily.wind_speed_10m_max[index],
      }));
      // Caching the results before returning
      this.cache.set(cacheKey, forecasts);
      return forecasts;
    } catch (error: any) {
      // Handling errors and throwing with detailed message
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to fetch weather forecast: ${errorMessage}`);
    }
  }
}