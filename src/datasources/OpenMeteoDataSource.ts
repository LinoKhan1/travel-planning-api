import { DataSource } from 'apollo-datasource';
import axios from 'axios';
import axiosRetry from 'axios-retry';
import { config } from 'dotenv';
import { City, WeatherForecast } from '../schema/types'; // Generated by codegen

config(); // Load environment variables

interface GeocodingResponse {
  results?: Array<{
    id: number;
    name: string;
    latitude: number;
    longitude: number;
    country?: string;
    population?: number;
  }>;
}

interface WeatherResponse {
  daily: {
    time: string[];
    temperature_2m_max: number[];
    temperature_2m_min: number[];
    precipitation_sum: number[];
    wind_speed_10m_max: number[];
  };
}

export class OpenMeteoDataSource extends DataSource {
  private client: ReturnType<typeof axios.create>;

  constructor() {
    super();
    this.client = axios.create({
      baseURL: process.env.OPEN_METEO_GEOCODING_URL || 'https://geocoding-api.open-meteo.com/v1',
      timeout: 5000,
    });
    axiosRetry(this.client, {
      retries: 3,
      retryDelay: (retryCount: number) => axiosRetry.exponentialDelay(retryCount),
      retryCondition: (error: any) => error.response?.status === 429 || error.code === 'ECONNABORTED' || error.code === 'ERR_NETWORK',
    });
  }

  async searchCities(query: string, limit: number): Promise<City[]> {
    try {
      const response = await this.client.get<GeocodingResponse>('/search', {
        params: { name: query, count: limit, language: 'en' },
      });
      if (!response.data.results || response.data.results.length === 0) {
        return [];
      }
      return response.data.results.map((result) => ({
        id: result.id.toString(),
        name: result.name,
        latitude: result.latitude,
        longitude: result.longitude,
        country: result.country ?? null,
        population: result.population ?? null,
      }));
    } catch (error: any) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to fetch cities: ${errorMessage}`);
    }
  }

  async getWeatherForecast(latitude: number, longitude: number, forecastDays: number): Promise<WeatherForecast[]> {
    try {
      const response = await this.client.get<WeatherResponse>('/forecast', {
        baseURL: process.env.OPEN_METEO_FORECAST_URL || 'https://api.open-meteo.com/v1',
        params: {
          latitude,
          longitude,
          daily: 'temperature_2m_max,temperature_2m_min,precipitation_sum,wind_speed_10m_max',
          timezone: 'auto',
          forecast_days: forecastDays,
        },
      });
      const { daily } = response.data;
      return daily.time.map((date: string, index: number) => ({
        date,
        temperatureMax: daily.temperature_2m_max[index],
        temperatureMin: daily.temperature_2m_min[index],
        precipitationSum: daily.precipitation_sum[index],
        windSpeedMax: daily.wind_speed_10m_max[index],
      }));
    } catch (error: any) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to fetch weather forecast: ${errorMessage}`);
    }
  }
}